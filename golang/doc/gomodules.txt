1.把golang项目放到gopath之外
2.在main.go所在根目录执行go mod init <module_name>
3.安装依赖 go mod edit -requied xxx

Introduction to Go Modules
Posted on 2018-08-18 by Roberto Selbach
The upcoming version 1.11 of the Go programming language will bring experimental support for modules, a new dependency management system for Go.A few days ago, I wrote a quick post about it. Since that post went live, things changed a bit and as we’re now very close to the new release, I thought it would be a good time for another post with a more hands-on approach.So here’s what we’ll do: we’ll create a new package and then we’ll make a few releases to see how that would work.
Creating a Module
So first things first. Let’s create our package. We’ll call it “testmod”. An important detail here: this directory should be outside your $GOPATH because by default, the modules support is disabled inside it. Go modules is a first step in potentially eliminating $GOPATH entirely at some point.
$ mkdir testmod
$ cd testmod
Our package is very simple:
package testmod

import "fmt" 

// Hi returns a friendly greeting
func Hi(name string) string {
   return fmt.Sprintf("Hi, %s", name)
}
The package is done but it is still not a module. Let’s change that.
$ go mod init github.com/robteix/testmod
go: creating new go.mod: module github.com/robteix/testmod
This creates a new file named go.mod in the package directory with the following contents:
module github.com/robteix/testmod
Not a lot here, but this effectively turns our package into a module.We can now push this code to a repository:
$ git init 
$ git add * 
$ git commit -am "First commit" 
$ git push -u origin master
Until now, anyone willing to use this package would go get it:
$ go get github.com/robteix/testmod
And this would fetch the latest code in master. This still works, but we should probably stop doing that now that we have a Better Way™. Fetching master is inherently dangerous as we can never know for sure that the package authors didn’t make change that will break our usage. That’s what modules aims at fixing.
Quick Intro to Module Versioning
Go modules are versioned, and there are some particularities with regards to certain versions. You will need to familiarize yourself with the concepts behind semantic versioning.More importantly, Go will use repository tags when looking for versions, and some versions are different of others: e.g. versions 2 and greater should have a different import path than versions 0 and 1 (we’ll get to that.)As well, by default Go will fetch the latest tagged version available in a repository. This is an important gotcha as you may be used to working with the master branch.What you need to keep in mind for now is that to make a release of our package, we need to tag our repository with the version. So let’s do that.
Making our first release
Now that our package is ready, we can release it to the world. We do this by using version tags. Let’s release our version 1.0.0:
$ git tag v1.0.0
$ git push --tags
This creates a tag on my Github repository marking the current commit as being the release 1.0.0.Go doesn’t enforce that in any way, but a good idea is to also create a new branch (“v1”) so that we can push bug fixes to.
$ git checkout -b v1
$ git push -u origin v1
Now we can work on master without having to worry about breaking our release.
Using our module
Now we’re ready to use the module. We’ll create a simple program that will use our new package:
package main

import (
    "fmt"

    "github.com/robteix/testmod"
)

func main() {
    fmt.Println(testmod.Hi("roberto"))
}
Until now, you would do a go get github.com/robteix/testmod to download the package, but with modules, this gets more interesting. First we need to enable modules in our new program.
$ go mod init mod
As you’d expect from what we’ve seen above, this will have created a new go.mod file with the module name in it:
module mod
Things get much more interesting when we try to build our new program:
$ go build
go: finding github.com/robteix/testmod v1.0.0
go: downloading github.com/robteix/testmod v1.0.0
As we can see, the go command automatically goes and fetches the packages imported by the program. If we check our go.mod file, we see that things have changed:
module mod
require github.com/robteix/testmod v1.0.0
And we now have a new file too, named go.sum, which contains hashes of the packages, to ensure that we have the correct version and files.
github.com/robteix/testmod v1.0.0 h1:9EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA=
github.com/robteix/testmod v1.0.0/go.mod h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=
Making a bugfix release
Now let’s say we realized a problem with our package: the greeting is missing ponctuation! People are mad because our friendly greeting is not friendly enough. So we’ll fix it and release a new version:
// Hi returns a friendly greeting
func Hi(name string) string {
-       return fmt.Sprintf("Hi, %s", name)
+       return fmt.Sprintf("Hi, %s!", name)
}
We made this change in the v1 branch because it’s not relevant for what we’ll do for v2 later, but in real life, maybe you’d do it in master and then back-port it. Either way, we need to have the fix in our v1 branch and mark it as a new release.
$ git commit -m "Emphasize our friendliness" testmod.go
$ git tag v1.0.1
$ git push --tags origin v1
Updating modules
By default, Go will not update modules without being asked. This is a Good Thing™ as we want predictability in our builds. If Go modules were automatically updated every time a new version came out, we’d be back in the uncivilized age pre-Go1.11. No, we need to tell Go to update a modules for us.We do this by using our good old friend go get:
run go get -u to use the latest minor or patch releases (i.e. it would update from 1.0.0 to, say, 1.0.1 or, if available, 1.1.0)
run go get -u=patch to use the latest patch releases (i.e., would update to 1.0.1 but not to 1.1.0)
run go get package@version to update to a specific version (say, github.com/robteix/testmod@v1.0.1)
In the list above, there doesn’t seem to be a way to update to the latest major version. There’s a good reason for that, as we’ll see in a bit.Since our program was using version 1.0.0 of our package and we just created version 1.0.1, any of the following commands will update us to 1.0.1:
$ go get -u
$ go get -u=patch
$ go get github.com/robteix/testmod@v1.0.1
After running, say, go get -u our go.mod is changed to:
module mod
require github.com/robteix/testmod v1.0.1
Major versions
According to semantic version semantics, a major version is different than minors. Major versions can break backwards compatibility. From the point of view of Go modules, a major version is a different package completely. This may sound bizarre at first, but it makes sense: two versions of a library that are not compatible with each other are two different libraries.Let’s make a major change in our package, shall we? Over time, we realized our API was too simple, too limited for the use cases of our users, so we need to change the Hi() function to take a new parameter for the greeting language:
package testmod

import (
    "errors"
    "fmt" 
) 

// Hi returns a friendly greeting in language lang
func Hi(name, lang string) (string, error) {
    switch lang {
    case "en":
        return fmt.Sprintf("Hi, %s!", name), nil
    case "pt":
        return fmt.Sprintf("Oi, %s!", name), nil
    case "es":
        return fmt.Sprintf("¡Hola, %s!", name), nil
    case "fr":
        return fmt.Sprintf("Bonjour, %s!", name), nil
    default:
        return "", errors.New("unknown language")
    }
}
Existing software using our API will break because they (a) don’t pass a language parameter and (b) don’t expect an error return. Our new API is no longer compatible with version 1.x so it’s time to bump the version to 2.0.0.I mentioned before that some versions have some peculiarities, and this is the case now. Versions 2 and over should change the import path. They are different libraries now.We do this by appending a new version path to the end of our module name.
module github.com/robteix/testmod/v2
The rest is the same as before, we push it, tag it as v2.0.0 (and optionally create a v2 branch.)
$ git commit testmod.go -m "Change Hi to allow multilang"
$ git checkout -b v2 # optional but recommended
$ echo "module github.com/robteix/testmod/v2" > go.mod
$ git commit go.mod -m "Bump version to v2"
$ git tag v2.0.0
$ git push --tags origin v2 # or master if we don't have a branch
Updating to a major version
Even though we have released a new incompatible version of our library, existing software will not break, because it will continue to use the existing version 1.0.1. go get -u will not get version 2.0.0.At some point, however, I, as the library user, may want to upgrade to version 2.0.0 because maybe I was one of those users who needed multi-language support.I do it but modifying my program accordingly:
package main

import (
    "fmt"
    "github.com/robteix/testmod/v2" 
)

func main() {
    g, err := testmod.Hi("Roberto", "pt")
    if err != nil {
        panic(err)
    }
    fmt.Println(g)
}
And then when I run go build, it will go and fetch version 2.0.0 for me. Notice how even though the import path ends with “v2”, Go will still refer to the module by its proper name (“testmod”).As I mentioned before, the major version is for all intents and purposes a completely different package. Go modules does not link the two at all. That means we can use two incompatible versions in the same binary:
package main
import (
    "fmt"
    "github.com/robteix/testmod"
    testmodML "github.com/robteix/testmod/v2"
)

func main() {
    fmt.Println(testmod.Hi("Roberto"))
    g, err := testmodML.Hi("Roberto", "pt")
    if err != nil {
        panic(err)
    }
    fmt.Println(g)
}
This eliminates a common problem with dependency management: when dependencies depend on different versions of the same library.
Tidying it up
Going back to the previous version that uses only testmod 2.0.0, if we check the contents of go.mod now, we’ll notice something:
module mod
require github.com/robteix/testmod v1.0.1
require github.com/robteix/testmod/v2 v2.0.0
By default, Go does not remove a dependency from go.mod unless you ask it to. If you have dependencies that you no longer use and want to clean up, you can use the new tidy command:
$ go mod tidy
Now we’re left with only the dependencies that are really being used.
Vendoring
Go modules ignores the vendor/ directory by default. The idea is to eventually do away with vendoring1. But if we still want to add vendored dependencies to our version control, we can still do it:
$ go mod vendor
This will create a vendor/ directory under the root of your project containing the source code for all of your dependencies.Still, go build will ignore the contents of this directory by default. If you want to build dependencies from the vendor/ directory, you’ll need to ask for it.
$ go build -mod vendor
I expect many developers willing to use vendoring will run go build normally on their development machines and use -mod vendor in their CI.Again, Go modules is moving away from the idea of vendoring and towards using a Go module proxy for those who don’t want to depend on the upstream version control services directly.There are ways to guarantee that go will not reach the network at all (e.g. GOPROXY=off) but these are the subject for a future blog post.
Conclusion
This post may seem a bit daunting, but I tried to explain a lot of things together. The reality is that now Go modules is basically transparent. We import package like always in our code and the go command will take care of the rest.When we build something, the dependencies will be fetched automatically. It also eliminates the need to use $GOPATH which was a roadblock for new Go developers who had trouble understanding why things had to go into a specific directory.Vendoring is (unofficially) being deprecated in favour of using proxies.1 I may do a separate post about the Go module proxy. (Update: it’s live.)
I think this came out a bit too strong and people left with the impression that vendoring is being removed right now. It isn’t. Vendoring still works, albeit slightly different than before. There seems to be a desire to replace vendoring with something better, which may or may not be a proxy. But for now this is just it: a desire for a better solution. Vendoring is not going away until a good replacement is found (if ever.) ↩ ↩
Posted in
Go
|
Programming
Tagged modules | vgo

Quick Start
Example
The details are covered in the remainder of this page, but here is a simple example of creating a module from scratch.

Create a directory outside of your GOPATH:

$ mkdir -p /tmp/scratchpad/hello
$ cd /tmp/scratchpad/hello
Initialize a new module:

$ go mod init github.com/you/hello

go: creating new go.mod: module github.com/you/hello
Write your code:

$ cat <<EOF > hello.go
package main

import (
    "fmt"
    "rsc.io/quote"
)

func main() {
    fmt.Println(quote.Hello())
}
EOF
Build and run:

$ go build 
$ ./hello

Hello, world.
The go.mod file was updated to include explicit versions for your dependencies, where v1.5.2 here is a semver tag:

$ cat go.mod

module github.com/you/hello

require rsc.io/quote v1.5.2
Daily Workflow
Note there was no go get required in the example above.

Your typical day-to-day workflow can be:

Add import statements to your .go code as needed.
Standard commands like go build or go test will automatically add new dependencies as needed to satisfy imports (updating go.mod and downloading the new dependencies).
When needed, more specific versions of dependencies can be chosen with commands such as go get foo@v1.2.3, go get foo@master, go get foo@e3702bed2, or by editing go.mod directly.
A brief tour of other common functionality you might use:

go list -m all — View final versions that will be used in a build for all direct and indirect dependencies (details)
go list -u -m all — View available minor and patch upgrades for all direct and indirect dependencies (details)
go get -u or go get -u=patch — Update all direct and indirect dependencies to latest minor or patch upgrades (pre-releases are ignored) (details)
go build ./... or go test ./... — Build or test all packages in the module when run from the module root directory (details)
go mod tidy — Prune any no-longer-needed dependencies from go.mod and add any dependencies needed for other combinations of OS, architecture, and build tags (details)
replace directive or gohack — Use a fork, local copy or exact version of a dependency (details)
go mod vendor — Optional step to create a vendor directory (details)
After reading the next four sections on "New Concepts", you will have enough information to get started with modules for most projects. It is also useful to review the Table of Contents above (including the FAQ one-liners there) to familiarize yourself with the list of more detailed topics.

New Concepts
These sections provide a high-level introduction to the main new concepts. For more details and rationale, please see this 40-minute introductory video by Russ Cox describing the philosophy behind the design, the official proposal document, or the more detailed initial vgo blog series.

Modules
A module is a collection of related Go packages that are versioned together as a single unit.

Modules record precise dependency requirements and create reproducible builds.

Most often, a version control repository contains exactly one module defined in the repository root. (Multiple modules are supported in a single repository, but typically that would result in more work on an on-going basis than a single module per repository).

Summarizing the relationship between repositories, modules, and packages:

A repository contains one or more Go modules.
Each module contains one or more Go packages.
Each package consists of one or more Go source files in a single directory.
Modules must be semantically versioned according to semver, usually in the form v(major).(minor).(patch), such as v0.1.0, v1.2.3, or v1.5.0-rc.1. The leading v is required. If using Git, tag released commits with their versions. Public and private module repositories and proxies are becoming available (see FAQ below).

go.mod
A module is defined by a tree of Go source files with a go.mod file in the tree's root directory. Module source code may be located outside of GOPATH. There are four directives: module, require, replace, exclude.

Here is an example go.mod file defining the module github.com/my/thing:

module github.com/my/thing

require (
    github.com/some/dependency v1.2.3
    github.com/another/dependency/v4 v4.0.0
)
A module declares its identity in its go.mod via the module directive, which provides the module path. The import paths for all packages in a module share the module path as a common prefix. The module path and the relative path from the go.mod to a package's directory together determine a package's import path.

For example, if you are creating a module for a repository github.com/my/repo that will contain two packages with import paths github.com/my/repo/foo and github.com/my/repo/bar, then the first line in your go.mod file typically would declare your module path as module github.com/my/repo, and the corresponding on-disk structure could be:

repo/
├── go.mod
├── bar
│   └── bar.go
└── foo
    └── foo.go
In Go source code, packages are imported using the full path including the module path. For example, if a module declared its identity in its go.mod as module example.com/my/module, a consumer could do:

import "example.com/my/module/mypkg"
This imports package mypkg from the module example.com/my/module.

exclude and replace directives only operate on the current (“main”) module. exclude and replace directives in modules other than the main module are ignored when building the main module. The replace and exclude statements therefore allow the main module complete control over its own build, without also being subject to complete control by dependencies. (See FAQ below for discussion of when to use a replace directive).

Version Selection
If you add a new import to your source code that is not yet covered by a require in go.mod, most go commands like 'go build' and 'go test' will automatically look up the proper module and add the highest version of that new direct dependency to your module's go.mod as a require directive. For example, if your new import corresponds to dependency M whose latest tagged release version is v1.2.3, your module's go.mod will end up with require M v1.2.3, which indicates module M is a dependency with allowed version >= v1.2.3 (and < v2, given v2 is considered incompatible with v1).

The minimal version selection algorithm is used to select the versions of all modules used in a build. For each module in a build, the version selected by minimal version selection is always the semantically highest of the versions explicitly listed by a require directive in the main module or one of its dependencies.

As an example, if your module depends on module A which has a require D v1.0.0, and your module also depends on module B which has a require D v1.1.1, then minimal version selection would choose v1.1.1 of D to include in the build (given it is the highest listed require version). This selection of v1.1.1 remains consistent even if some time later a v1.2.0 of D becomes available. This is an example of how the modules system provides 100% reproducible builds. When ready, the module author or user might choose to upgrade to the latest available version of D or choose an explicit version for D.

For a brief rationale and overview of the minimal version selection algorithm, see the "High Fidelity Builds" section of the official proposal, or see the more detailed vgo blog series.

To see a list of the selected module versions (including indirect dependencies), use go list -m all.

See also the "How to Upgrade and Downgrade Dependencies" section below and the "How are versions marked as incompatible?" FAQ below.

Semantic Import Versioning
For many years, the official Go FAQ has included this advice on package versioning:

"Packages intended for public use should try to maintain backwards compatibility as they evolve. The Go 1 compatibility guidelines are a good reference here: don't remove exported names, encourage tagged composite literals, and so on. If different functionality is required, add a new name instead of changing an old one. If a complete break is required, create a new package with a new import path."

The last sentence is especially important — if you break compatibility, you should change the import path of your package. With Go 1.11 modules, that advice is formalized into the import compatibility rule:

"If an old package and a new package have the same import path, the new package must be backwards compatible with the old package."

Recall semver requires a major version change when a v1 or higher package makes a backwards incompatible change. The result of following both the import compatibility rule and semver is called Semantic Import Versioning, where the major version is included in the import path — this ensures the import path changes any time the major version increments due to a break in compatibility.

As a result of Semantic Import Versioning, code opting in to Go modules must comply with these rules:

Follow semver. (An example VCS tag is v1.2.3).
If the module is version v2 or higher, the major version of the module must be included as a /vN at the end of the module paths used in go.mod files (e.g., module github.com/my/mod/v2, require github.com/my/mod/v2 v2.0.0) and in the package import path (e.g., import "github.com/my/mod/v2/mypkg").
If the module is version v0 or v1, do not include the major version in either the module path or the import path.
In general, packages with different import paths are different packages. For example, math/rand is a different package than crypto/rand. This is also true if different import paths are due to different major versions appearing in the import path. Thus example.com/my/mod/mypkg is a different package than example.com/my/mod/v2/mypkg, and both may be imported in a single build, which among other benefits helps with diamond dependency problems and also allows a v1 module to be implemented in terms of its v2 replacement or vice versa.

See the "Module compatibility and semantic versioning" section of the go command documentation for more details on Semantic Import Versioning, and see https://semver.org for more about semantic versioning.

This section so far has been focused on code that has opted in to modules and imports other modules. However, putting major versions in import paths for v2+ modules could create incompatibilities with older versions of Go, or with code that has not yet opted in to modules. To help with this, there are three important transitional special cases or exceptions to the behavior and rules described above. These transitional exceptions will become less important over time as more packages opt in to modules.

Three Transitional Exceptions

gopkg.in

Existing code that uses import paths starting with gopkg.in (such as gopkg.in/yaml.v1 and gopkg.in/yaml.v2) can continue to use those forms for their module paths and import paths even after opting in to modules.

'+incompatible' when importing non-module v2+ packages

A module can import a v2+ package that has not opted in to modules itself. A non-module v2+ package that has a valid v2+ semver tag will be recorded with an +incompatible suffix in the importing module's go.mod file. The +incompatible suffix indicates that even though the v2+ package has a valid v2+ semver tag such as v2.0.0, the v2+ package has not actively opted in to modules and hence that v2+ package is assumed to have not been created with an understanding of the implications of Semantic Import Versioning and how to use major versions in import paths. Therefore, when operating in module mode, the go tool will treat a non-module v2+ package as an (incompatible) extension of the v1 version series of the package and assume the package has no awareness of Semantic Import Versioning, and the +incompatible suffix is an indication that the go tool is doing so.

"Minimal module compatibility" when module mode is not enabled

To help with backwards compatibility, Go versions 1.9.7+, 1.10.3+ and 1.11 have been updated to make it easier for code built with those releases to be able to properly consume v2+ modules without requiring modification of pre-existing code. This behavior is called "minimal module compatibility", and it only takes effect when full module mode is disabled for the go tool, such as if such as you have set GO111MODULE=off in Go 1.11, or are using Go versions 1.9.7+ or 1.10.3+. When relying on this "minimal module compatibility" mechanism in Go 1.9.7+, 1.10.3+ and 1.11, a package that has not opted in to modules would not include the major version in the import path for any imported v2+ modules. In contrast, a package that has opted in to modules must include the major version in the import path to import any v2+ modules (in order to properly import the v2+ module when the go tool is operating in full module mode with full awareness of Semantic Import Versioning).

For the exact mechanics required to release a v2+ module, please see the "Releasing Modules (v2 or Higher)" section below.

How to Use Modules
How to Install and Activate Module Support
To use modules, two install options are:

Install the latest Go 1.11 release.
Install the Go toolchain from source on the master branch.
Once installed, you can then activate module support in one of two ways:

Invoke the go command in a directory outside of the $GOPATH/src tree, with a valid go.mod file in the current directory or any parent of it and the environment variable GO111MODULE unset (or explicitly set to auto).
Invoke the go command with GO111MODULE=on environment variable set.
How to Define a Module
To create a go.mod for an existing project:

Navigate to the root of the module's source tree outside of GOPATH:

$ cd <project path outside $GOPATH/src>         # e.g., cd ~/projects/hello
Note that outside of GOPATH, you do not need to set GO111MODULE to activate module mode.

Alternatively, if you want to work in your GOPATH:

$ export GO111MODULE=on                         # manually active module mode
$ cd $GOPATH/src/<project path>                 # e.g., cd $GOPATH/src/you/hello
Create the initial module definition and write it to the go.mod file:

$ go mod init                  
This step converts from any existing dep Gopkg.lock file or from any of the other nine total supported dependency formats, adding require statements to match the existing configuration.

go mod init will often be able to use auxiliary data (such as VCS meta-data) to automatically determine the appropriate module path, but if go mod init states it can not automatically determine the module path, or if you need to otherwise override that path, you can supply the module path as an optional argument to go mod init, for example:

$ go mod init github.com/my/repo
Note that if your dependencies include v2+ modules, or if you are initializing a v2+ module, then after running go mod init you might also need to edit your go.mod and .go code to add /vN to import paths and module paths as described in the "Semantic Import Versioning" section above. This applies even if go mod init automatically converted your dependency information from dep or other dependency managers. (Because of this, after running go mod init, you typically should not run go mod tidy until you have successfully run go build ./... or similar, which is the sequence shown in this section).

Build the module. When executed from the root directory of a module, the ./... pattern matches all the packages within the current module. go build will automatically add missing or unconverted dependencies as needed to satisfy imports for this particular build invocation:

$ go build ./...
Test the module as configured to ensure that it works with the selected versions:

$ go test ./...
(Optional) Run the tests for your module plus the tests for all direct and indirect dependencies to check for incompatibilities:

$ go test all
Prior to tagging a release, see the "How to Prepare for a Release" section below.

For more information on all of these topics, the primary entry point to the official modules documentation is available on golang.org.

How to Upgrade and Downgrade Dependencies
Day-to-day upgrading and downgrading of dependencies should be done using 'go get', which will automatically update the go.mod file. Alternatively, you can edit go.mod directly.

In addition, go commands like 'go build', 'go test', or even 'go list' will automatically add new dependencies as needed to satisfy imports (updating go.mod and downloading the new dependencies).

To view available minor and patch upgrades for all direct and indirect dependencies, run go list -u -m all.

To upgrade to the latest version for all direct and indirect dependencies of the current module:

run go get -u to use the latest minor or patch releases
run go get -u=patch to use the latest patch releases
go get foo updates to the latest version of foo. go get foo is equivalent to go get foo@latest — in other words, @latest is the default if no @ version is specified.

In this section, "latest" is the latest version with a semver tag, or the latest known commit if there are no semver tags. Prerelease tags are not selected as "latest" unless there are no other semver tags on the repository (details).

A common mistake is thinking go get -u foo solely gets the latest version of foo. In actuality, the -u in go get -u foo or go get -u foo@latest means to also get the latest versions for all of the direct and indirect dependencies of foo. A common starting point when upgrading foo is instead to do go get foo or go get foo@latest without a -u (and after things are working, consider go get -u=patch foo, go get -u=patch, go get -u foo, or go get -u).

To upgrade or downgrade to a more specific version, 'go get' allows version selection to be overridden by adding an @version suffix or "module query" to the package argument, such as go get foo@v1.6.2, go get foo@e3702bed2, or go get foo@'<v1.6.2'.

Using a branch name such as go get foo@master is one way to obtain the latest commit regardless of whether or not it has a semver tag.

In general, module queries that do not resolve to a semver tag will be recorded as pseudo-versions in the go.mod file.

See the "Module-aware go get" and "Module queries" sections of the go command documentation for more information on the topics here.

Modules are capable of consuming packages that have not yet opted into modules, including recording any available semver tags in go.mod and using those semver tags to upgrade or downgrade. Modules can also consume packages that do not yet have any proper semver tags (in which case they will be recorded using pseudo-versions in go.mod).

After upgrading or downgrading any dependencies, you may then want to run the tests again for all packages in your build (including direct and indirect dependencies) to check for incompatibilities:

$ go test all
How to Prepare for a Release
Releasing Modules (All Versions)
Best practices for creating a release of a module are expected to emerge as part of the initial modules experiment. Many of these might end up being automated by a future 'go release' tool.

Some current suggested best practices to consider prior to tagging a release:

Run go mod tidy to possibly prune any extraneous requirements (as described here) and also ensure your current go.mod reflects all possible build tags/OS/architecture combinations (as described here).

In contrast, other commands like go build and go test will not remove dependencies from go.mod that are no longer required and only update go.mod based on the current build invocation's tags/OS/architecture.
Run go test all to test your module (including running the tests for your direct and indirect dependencies) as a way of validating that the currently selected packages versions are compatible.

The number of possible version combinations is exponential in the number of modules, so in general you cannot expect your dependencies to have tested against all possible combinations of their dependencies.
As part of the modules work, go test all has been re-defined to be more useful to include all the packages in the current module, plus all the packages they depend on through a sequence of one or more imports, while excluding packages that don't matter in the current module.
Ensure your go.sum file is committed along with your go.mod file. See FAQ below for more details and rationale.

Releasing Modules (v2 or Higher)
If you are releasing a v2 or higher module, please first review the discussion in the "Semantic Import Versioning" section above, which includes why major versions are included in the module path and import path for v2+ modules, as well as how Go versions 1.9.7+ and 1.10.3+ have been updated to simplify that transition.

Note that if you are adopting modules for the first time for a pre-existing repository or set of packages that have already been tagged v2.0.0 or higher before adopting modules, then the recommended best practice is to increment the major version when first adopting modules. For example, if you are the author of foo, and the latest tag for the foo repository is v2.2.2, and foo has not yet adopted modules, then the best practice would be to use v3.0.0 for the first release of foo to adopt modules (and hence the first release of foo to contain a go.mod file). Incrementing the major version in this case provides greater clarity to consumers of foo, allows for additional non-module patches or minor releases on the v2 series of foo if needed, and provides a strong signal for a module-based consumer of foo that different major versions result if you do import "foo" and a corresponding require foo v2.2.2+incompatible, vs. import "foo/v3" and a corresponding require foo/v3 v3.0.0. (Note that this advice regarding incrementing the major version when first adopting modules does not apply to pre-existing repos or packages whose latest versions are v0.x.x or v1.x.x).

There are two alternative mechanisms to release a v2 or higher module. Note that with both techniques, the new module release becomes available to consumers when the module author pushes the new tags. Using the example of creating a v3.0.0 release, the two options are:

Major branch: Update the go.mod file to include a /v3 at the end of the module path in the module directive (e.g., module github.com/my/module/v3). Update import statements within the module to also use /v3 (e.g., import "github.com/my/module/v3/mypkg"). Tag the release with v3.0.0.

Go versions 1.9.7+, 1.10.3+, and 1.11 are able to properly consume and build a v2+ module created using this approach without requiring updates to consumer code that has not yet opted in to modules (as described in the the "Semantic Import Versioning" section above).
A community tool github.com/marwan-at-work/mod helps automate this procedure. See the repository or the community tooling FAQ below for an overview.
To avoid confusion with this approach, consider putting the v3.*.* commits for the module on a separate v3 branch.
Note: creating a new branch is not required. If instead you have been previously releasing on master and would prefer to tag v3.0.0 on master, that is a viable option. (However, be aware that introducing an incompatible API change in master can cause issues for non-modules users who issue a go get -u given the go tool is not aware of semver prior to Go 1.11 or when module mode is not enabled in Go 1.11+).
Pre-existing dependency management solutions such as dep currently can have problems consuming a v2+ module created in this way. See for example dep#1962.
Major subdirectory: Create a new v3 subdirectory (e.g., my/module/v3) and place a new go.mod file in that subdirectory. The module path must end with /v3. Copy or move the code into the v3 subdirectory. Update import statements within the module to also use /v3 (e.g., import "github.com/my/module/v3/mypkg"). Tag the release with v3.0.0.

This provides greater backwards compatibility. In particular, Go versions older than 1.9.7 and 1.10.3 are also able to properly consume and build a v2+ module created using this approach.
A more sophisticated approach here could exploit type aliases (introduced in Go 1.9) and forwarding shims between major versions residing in different subdirectories. This can provide additional compatibility and allow one major version to be implemented in terms of another major version, but would entail more work for a module author. An in-progress tool to automate this is goforward. Please see here for more details and rationale, along with a functioning initial version of goforward.
Pre-existing dependency management solutions such as dep should be able to consume a v2+ module created in this way.
See https://research.swtch.com/vgo-module for a more in-depth discussion of these alternatives.

Publishing a release
A new module version may be published by pushing a tag to the repository that contains the module source code. The tag is formed by concatenating two strings: a prefix and a version.

The version is the semantic import version for the release. It should be chosen by following the rules of semantic import versioning.

The prefix indicates where a module is defined within a repository. If the module is defined at the root of the repository, the prefix is empty, and the tag is just the version. However, in multi-module repositories, the prefix distinguishes versions for different modules. The prefix is the directory within the repository where the module is defined. If the repository follows the major subdirectory pattern described above, the prefix does not include the major version suffix.

For example, suppose we have a module example.com/repo/sub/v2, and we want to publish version v2.1.6. The repository root corresponds to example.com/repo, and the module is defined in sub/v2/go.mod within the repository. The prefix for this module is sub/. The full tag for this release should be sub/v2.1.6.

Migrating to Modules
This section attempts to briefly enumerate the major decisions to be made when migrating to modules as well as list other migration-related topics. References are generally provided to other sections for more details.

This material is primarily based on best practices that have emerged from the community as part of the modules experiment; this is therefore a work-in-progress section that will improve over time as the community gains more experience.

Summary:

The modules system is designed to allow different packages in the overall Go ecosystem to opt in at different rates.
Packages that are already on version v2 or higher have more migration considerations, primarily due to the implications of Semantic Import versioning.
New packages and packages on v0 or v1 have substantially fewer considerations when adopting modules.
Modules defined with Go 1.11 can be used by older Go versions (although the exact Go versions depends on the strategy used by the main module and its dependencies, as outlined below).
Migration topics:

Automatic Migration from Prior Dependency Managers
go mod init automatically translates the required information from dep, glide, govendor, godep and 5 other pre-existing dependency managers into a go.mod file that produces the equivalent build.
If you are creating a v2+ module, be sure your module directive in the converted go.mod includes the appropriate /vN (e.g., module foo/v3).
Note that if you are importing v2+ modules, you might need to do some manual adjustments after an initial conversion in order to add /vN to the require statements that go mod init generates after translating from a prior dependency manager. See the "How to Define a Module" section above for more details.
In addition, go mod init will not edit your .go code to add any required /vN to import statements. See the "Semantic Import versioning" and "Releasing Modules (v2 or Higher)" sections above for the required steps, including some options around community tools to automate the conversion.
Providing Dependency Information to Older Versions of Go and Non-Module Consumers
Older versions of Go understand how to consume a vendor directory created by go mod vendor, as do Go 1.11 and 1.12+ when module mode is disabled. Therefore, vendoring is one way for a module to provide dependencies to older versions of Go that do not fully understand modules, as well as to consumers that have not enabled modules themselves. See the vendoring FAQ and the go command documentation for more details.
Updating Pre-Existing Install Instructions
Pre-modules, it is common for install instructions to include go get -u foo. If you are publishing a module foo, consider dropping the -u in instructions for modules-based consumers.
-u asks the go tool to upgrade all the direct and indirect dependencies of foo.
A module consumer might choose to run go get -u foo later, but there are more benefits of "High Fidelity Builds" if -u is not part of the initial install instructions. See "How to Upgrade and Downgrade Dependencies" for more details.
go get -u foo does still work, and can still be a valid choice for install instructions.
In addition, go get foo is not strictly needed for a module-based consumer.
Simply adding an import statement import "foo" is sufficient. (Subsequent commands like go build or go test will automatically download foo and update go.mod as needed).
Module-based consumers will not use a vendor directory by default.
When module mode is enabled in the go tool, vendor is not strictly required when consuming a module (given the information contained in go.mod and the cryptographic checksums in go.sum), but some pre-existing install instructions assume the go tool will use vendor by default. See the vendoring FAQ for more details.
Install instructions that include go get foo/... might have issues in some cases (see discussion in #27215).
Avoid Breaking Existing Import Paths
A module declares its identity in its go.mod via the module directive, such as module github.com/my/module. All packages within the module must be imported by any module-aware consumer with import paths that match the module's declared module path (either exactly for a root package, or with the module path as a prefix of the import path). The go command reports an unexpected module path error if there is a mismatch between an import path vs. the corresponding module's declared module path.

When adopting modules for a pre-existing set of packages, care should be taken to avoid breaking existing import paths used by existing consumers, unless you are incrementing your major version when adopting modules.

For example, if your pre-existing README has been telling consumers to use import "gopkg.in/foo.v1", and if you then adopt modules with a v1 release, your initial go.mod should almost certainly read module gopkg.in/foo.v1. If you wanted to move away from using gopkg.in, that would be a breaking change for your current consumers. One approach would be to change to something like module github.com/repo/foo/v2 if you later move to v2.

Note that module paths and import paths are case-sensitive. Changing a module from github.com/Sirupsen/logrus to github.com/sirupsen/logrus for example is a breaking change for consumers, even if GitHub automatically forwards from one repository name to the new repository name.

After you have adopted modules, changing your module path in your go.mod is a breaking change.

Overall, this is similar to the pre-modules enforcement of a canonical import path via "import path comments", which are also sometimes called "import pragmas" or "import path enforcement". As an example, the package go.uber.org/zap is currently hosted at github.com/uber-go/zap, but uses an import path comment next to the package declaration that triggers an error for any pre-modules consumer using the wrong github-based import path:

package zap // import "go.uber.org/zap"

Import path comments are obsoleted by the go.mod file's module statement.

Incrementing the Major Version When First Adopting Modules with v2+ Packages
If you have packages that have already been tagged v2.0.0 or higher before adopting modules, then the recommended best practice is to increment the major version when first adopting modules. For example, if you are on v2.0.1 and have not yet adopted modules, then you would use v3.0.0 for the first release that adopts modules. See the "Releasing Modules (v2 or Higher)" section above for more details.
v2+ Modules Allow Multiple Major Versions Within a Single Build
If a module is on v2 or higher, an implication is that multiple major versions can be in a single build (e.g., foo and foo/v3 might end up in a single build).
This flows naturally from the rule that "packages with different import paths are different packages".
When this happens, there will be multiple copies of package-level state (e.g., package-level state for foo and package-level state for foo/v3) as well as each major version will run its own init function.
This approach helps with multiple aspects of the modules system, including helping with diamond dependency problems, gradual migration to new versions within large code bases, and allowing a major version to be implemented as a shim around a different major version.
See the "Avoiding Singleton Problems" section of https://research.swtch.com/vgo-import or #27514 for some related discussion.
Modules Consuming Non-Module Code
Modules are capable of consuming packages that have not yet opted into modules, with the appropriate package version information recorded in the importing module's go.mod. Modules can consume packages that do not yet have any proper semver tags. See FAQ below for more details.
Modules can also import a v2+ package that has not opted into modules. It will be recorded with an +incompatible suffix if the imported v2+ package has valid semver tags. See FAQ below for more details.
Non-Module Code Consuming Modules
Non-module code consuming v0 and v1 modules:

Code that has not yet opted in to modules can consume and build v0 and v1 modules (without any requirement related to the Go version used).
Non-module code consuming v2+ modules:

Go versions 1.9.7+, 1.10.3+ and 1.11 have been updated so that code built with those releases can properly consume v2+ modules without requiring modification of pre-existing code as described in the "Semantic Import versioning" and "Releasing Modules (v2 or Higher)" sections above.

Go versions prior to 1.9.7 and 1.10.3 can consume v2+ modules if the v2+ module was created following the "Major subdirectory" approach outlined in the "Releasing Modules (v2 or Higher)" section.

Strategies for Authors of Pre-Existing v2+ Packages
For authors of pre-existing v2+ packages considering opting in to modules, one way to summarize the alternative approaches is as a choice between three top-level strategies . Each choice then has follow-on decisions and variations (as outlined above). These alternative top-level strategies are:

Require clients to use Go versions 1.9.7+, 1.10.3+, or 1.11+.

The approach uses the "Major Branch" approach and relies on the "minimal module awareness" that was backported to 1.9.7 and 1.10.3. See the "Semantic Import versioning" and "Releasing Modules (v2 or Higher)" sections above for more details.

Allow clients to use even older Go versions like Go 1.8.

This approach uses the "Major Subdirectory" approach and involves creating a subdirectory such as /v2 or /v3. See the "Semantic Import versioning" and "Releasing Modules (v2 or Higher)" sections above for more details.

Wait on opting in to modules.

In this strategy, things continue to work with client code that has opted in to modules as well as with client code that has not opted in to modules. As time goes by, Go versions 1.9.7+, 1.10.3+, and 1.11+ will be out for an increasingly longer time period, and at some point in the future, it becomes more natural or client-friendly to require Go versions 1.9.7+/1.10.3+/1.11+, and at that point in time, you can implement strategy 1 above (requiring Go versions 1.9.7+, 1.10.3+, or 1.11+) or even strategy 2 above (though if you are ultimately going to go with strategy 2 above in order to support older Go versions like 1.8, then that is something you can do now).

Additional Resources
Documentation and Proposal
Official documentation:
Latest HTML documentation for modules on golang.org
Run go help modules for more about modules. (This is the main entry point for modules topics via go help)
Run go help mod for more about the go mod command.
Run go help module-get for more about the behavior of go get when in module-aware mode.
Run go help goproxy for more about the module proxy, including a pure file-based option via a file:/// URL.
The initial "Go & Versioning" series of blog posts on vgo by Russ Cox (first posted February 20, 2018)
Official golang.org blog post introducing the proposal (March 26, 2018)
This provides a more succinct overview of the proposal than the full vgo blog series, along with some of the history and process behind the proposal
Official Versioned Go Modules Proposal (last updated March 20, 2018)
Introductory Material
Introductory 40 minute video "The Principles of Versions in Go" from GopherCon Singapore by Russ Cox (May 2, 2018)
Succinctly covers the philosophy behind the design of versioned Go modules, including the three core principles of "Compatibility", "Repeatability", and "Cooperation"
Example based 35 minute introductory video "What are Go modules and how do I use them?" (slides) by Paul Jolly (August 15, 2018)
Introductory blog post "Taking Go Modules for a Spin" by Dave Cheney (July 14, 2018)
Introductory Go Meetup slides on modules by Chris Hines (July 16, 2018)
Introductory 30 minute video "Intro to Go Modules and SemVer" by Francesc Campoy (Nov 15, 2018)
Additional Material
Blog post "Using Go modules with vendor support on Travis CI" by Fatih Arslan (August 26, 2018)
Blog post "Go Modules and CircleCI" by Todd Keech (July 30, 2018)
Blog post "The vgo proposal is accepted. Now what?" by Russ Cox (May 29, 2018)
Includes summary of what it means that versioned modules are currently an experimental opt-in feature
Blog post on how to build go from tip and start using go modules by Carolyn Van Slyck (July 16, 2018)
Changes Since the Initial Vgo Proposal
As part of the proposal, prototype, and beta processes, there have been over 400 issues created by the overall community. Please continue to supply feedback.

Here is a partial list of some of the larger changes and improvements, almost all of which were primarily based on feedback from the community:

Top-level vendor support was retained rather than vgo-based builds ignoring vendor directories entirely (discussion, CL)
Backported minimal module-awareness to allow older Go versions 1.9.7+ and 1.10.3+ to more easily consume modules for v2+ projects (discussion, CL)
Allowed vgo to use v2+ tags by default for pre-existing packages did not yet have a go.mod (recent update in related behavior described here)
Added support via command go get -u=patch to update all transitive dependencies to the latest available patch-level versions on the same minor version (discussion, documentation)
Additional control via environmental variables (e.g., GOFLAGS in #26585, CL)
Finer grain control on whether or not go.mod is allowed to be updated, how vendor directory is used, and whether or not network access is allowed (e.g., -mod=readonly, -mod=vendor, GOPROXY=off; related CL for recent change)
Added more flexible replace directives (CL)
Added additional ways to interrogate modules (for human consumption, as well as for better editor / IDE integration)
The UX of the go CLI has continued to be refined based on experiences so far (e.g., #26581, CL)
Additional support for warming caches for use cases such as CI or docker builds via go mod download (#26610)
Most likely: better support for installing specific versions of programs to GOBIN (#24250)